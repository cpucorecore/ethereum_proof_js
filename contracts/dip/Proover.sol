pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

import "./Util.sol";
import "./RLPUtil.sol";

contract prover {
    address public admin;

    constructor() public {
        admin = msg.sender;
    }

    // block header: 0xf90215a07b3677b7a9c7a10698a6626b7a563168d70d075b20dc4a34586f69d107215220a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d4934794037b539b0d6ae674c01cf5d9f84ea81b22532694a09fc4c68683db4aa2b60d4aa66ee87c4c62dd2ca97e4be40398f4b1135c511896a05bf56e745ff8705eb1f66747eaeda1ad215631b5ec84a9c4a5fd0f778cdc26f3a06d6b6ab9a687ab5fda5f81906af0407e5601c3730c4a10b34ddf46495996c514b90100000000000000000000000008000000000000000000000000002000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000004010000000000000000000000000000000000000000000000000000000000000008308bd64823b91837a1200825bf8845ffd524f9ad983010918846765746888676f312e31352e358664617277696ea01fb6eea3708aacac671c741e28215064b7553e78917c23e4bd8941b38efe0c16880bbf17bb8d9a3e9a
    // receipt: 0xf901bd01825bf8b9010000000000000000000000000800000000000000000000000000200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000401000000000000000000000000000000000000000000000000000000000000000f8b4f85894d389508032869c1701b9dbe3f5fc6df40c488bc7e1a02a056365f90644ba02872f61a1ad37613f47bba498327650b0b3ac40677e66c4a00000000000000000000000000000000000000000000000000000000000000064f85894d389508032869c1701b9dbe3f5fc6df40c488bc7e1a0f81f8171d13ab9fef6d56dec96341eba6a5265cec2002c22bbadc5f19d219720a00000000000000000000000000000000000000000000000000000000000000065
    // log entry: 0xf85894d389508032869c1701b9dbe3f5fc6df40c488bc7e1a02a056365f90644ba02872f61a1ad37613f47bba498327650b0b3ac40677e66c4a00000000000000000000000000000000000000000000000000000000000000064
    // proofArrayRLP: 0xf901c88080822080b901c0f901bd01825bf8b9010000000000000000000000000800000000000000000000000000200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000401000000000000000000000000000000000000000000000000000000000000000f8b4f85894d389508032869c1701b9dbe3f5fc6df40c488bc7e1a02a056365f90644ba02872f61a1ad37613f47bba498327650b0b3ac40677e66c4a00000000000000000000000000000000000000000000000000000000000000064f85894d389508032869c1701b9dbe3f5fc6df40c488bc7e1a0f81f8171d13ab9fef6d56dec96341eba6a5265cec2002c22bbadc5f19d219720a00000000000000000000000000000000000000000000000000000000000000065
    // proof: ["0x2080", "0xf901bd01825bf8b9010000000000000000000000000800000000000000000000000000200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000401000000000000000000000000000000000000000000000000000000000000000f8b4f85894d389508032869c1701b9dbe3f5fc6df40c488bc7e1a02a056365f90644ba02872f61a1ad37613f47bba498327650b0b3ac40677e66c4a00000000000000000000000000000000000000000000000000000000000000064f85894d389508032869c1701b9dbe3f5fc6df40c488bc7e1a0f81f8171d13ab9fef6d56dec96341eba6a5265cec2002c22bbadc5f19d219720a00000000000000000000000000000000000000000000000000000000000000065"]
    function verify_log_entry(
        uint64 log_index,
        bytes memory log_entry_data,
        uint64 receipt_index,
        bytes memory receipt_data,
        bytes memory header_data,
        bytes memory proofRLP,
        bool skip_bridge_call
    ) public returns (bool) {
        // RLP decode: log entry
        RLPUtil.LogEntry memory logEntry = RLPUtil.DecodeLogEntry(log_entry_data);

        // RLP decode: receipt
        RLPUtil.Receipt memory receipt = RLPUtil.DecodeReceipt(receipt_data);

        // RLP decode: block header
        RLPUtil.Header memory header = RLPUtil.DecodeHeader(header_data);

        // RLP decode: proof, bytes --> bytes[]
        bytes[] memory proof = RLPUtil.DecodeProof(proofRLP);

        // Verify log_entry included in receipt
        RLPUtil.LogEntry memory logInReceipt = receipt.logs[log_index];
        if (!Util.LogEntryEqual(logEntry, logInReceipt)) return false;

        // Verify receipt included into header
        bytes memory receipt_index_rlp = RLPEncode.encodeUint(receipt_index);
        bool result = verify_trie_proof(header.receipts_root, receipt_index_rlp, proof, receipt_data);

        // Verify block header was in the bridge
    }

    bytes public td;
    uint public tl;
    function test(uint n) public {
        td = RLPEncode.encodeUint(n);
        tl = td.length;
    }

    function verify_trie_proof(bytes memory expected_root, bytes memory key, bytes[] memory proof, bytes memory expected_value) public returns (bool) {
        bytes memory actual_key = Util.ExtractNibbles(key);
        // bytes storage actual_keyt = new bytes(1024); //todo

        // for(uint i=0;i<key.length;i++) {
        //     if ((actual_keyt.length + 1) == proof.length) {
        //         actual_keyt.push(key[i]);
        //     }
        // }

        // bytes memory actual_key = actual_keyt;
        _verify_trie_proof(expected_root, actual_key, proof, 0, 0, expected_value);
    }

    bytes32 public k1;
    bytes32 public k2;

    function _verify_trie_proof(bytes memory expected_root, bytes memory key, bytes[] memory proof, uint key_index, uint proof_index, bytes memory expected_value) public returns (bool) {
        bytes memory node = proof[proof_index];

        if (key_index == 0) {
            k1 = keccak256(node);
            bytes memory d = Util.ConcatNibbles(node);
            k2 = keccak256(d);
        }
    }
}
